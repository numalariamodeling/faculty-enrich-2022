---
title: "EMOD How Tos"
author: "Anne Stahlfeld & Tobias Holden"
date: "4/18/2022"
output: 
  blogdown::html_page:
    toc: true
---

{{< toc >}}

## Create a demographics file

The demographics file specifies characteristics of the population in a simulation. This includes things like the population size, distribution of age/gender, immunity, biting/mortality risks, and more.

At least one demographics file is required for every simulation unless you set the parameter **Enable_Demographics_Builtin** to 1 (one) in the configuration file. This setting does not represent a real location and is generally only used for testing and validating code.

<details><summary><span style="color: blue";">1. Create CSV</span></summary>
<p>

Create a file "my_node.csv" with the following columns:

**Required**

- nodeid (unique # 1-n, for n nodes)
- population (starting population size)

*Optional*

- Village (clearer labels than nodeID)
- Other node-specific variables (if any)

Example "my_node.csv":

| nodeid      | population  |  Village |
| ----------- | ----------- | -------- |
| 1      | 1400       | "Obom" |

</p>
</details>

<details><summary><span style="color: blue";">2. Run generate_demographics()</span></summary>
<p>

```{python, eval=F}
import json
from dtk.tools.demographics.DemographicsGeneratorConcern import WorldBankBirthRateConcern, EquilibriumAgeDistributionConcern, DefaultIndividualAttributesConcern
from dtk.tools.demographics.DemographicsGenerator import DemographicsGenerator

##### Example for Ghana #####
#############################


def generate_demographics(demo_df, demo_fname, days_spread=1) :
  # Get WorldBank birth rate estimate
  # UPDATE country and birthrate_year
  br_concern = WorldBankBirthRateConcern(country="Ghana", birthrate_year=2016)

  chain = [
        DefaultIndividualAttributesConcern(),
        br_concern,
        EquilibriumAgeDistributionConcern(default_birth_rate=br_concern.default_birth_rate),
    ]

    current: Dict[str, 
                  Union[List[Dict[str,Union[Union[int, Dict[Any, Any]], Any]]], 
                        Dict[Any, Any], 
                        Dict[str, Union[str, int]]]] = DemographicsGenerator.from_dataframe(demo_df,
                                                   population_column_name='population',
                                                   nodeid_column_name='nodeid',
                                                   node_id_from_lat_long=False,
                                                   concerns=chain,
                                                   load_other_columns_as_attributes=True,
                                                   include_columns=['Village'])  # Add any "optional" columns

    with open(demo_fname, 'w') as fout :
      json.dump(current, fout, sort_keys=True,indent=4, separators=(',', ': '))

    
    
df = pd.read_csv(".../my_node.csv")    
demo_fname = ".../FILENAME_demographics.json"

generate_demographics(df, demo_fname)
```
</p>
</details>

<details><summary><span style="color: blue";">3. Reading your Demographics File</span></summary>
<p>

The resulting demographics file is a JSON file organized into 4 main sections:

1. Metadata
2. NodeProperties
3. Defaults
    - Parameters applied to all nodes in the simulation
4. Nodes
    - Allows node-specific parameters
    - Duplicated parameters override values in 'Defaults'

```{python, eval=F}
# Structure of Demographics File for a simulation with 1 node
  {
     "Metadata": {
          "DateCreated": "dateTime",
          "Tool": "scriptUsedToGenerate",
          "Author": "author",
          "IdReference": "Gridded world grump2.5arcmin",
          "NodeCount": "1"
     },
     "NodeProperties": [
          {...}
     ],
     "Defaults": {
          "NodeAttributes": {
            ...
            "BirthRateSource": "World Bank",
            "CountryBirthRate": 31.047,
            "World Bank Year": "2016",
            ...
          },
          "IndividualAttributes": {...},
          "IndividualProperties": {...}
     },
     "Nodes": [{
          "NodeID": 1,
          "NodeAttributes": {
            "BirthRate": 0.1190,
            "InitialPopulation": 1400,
            "Village": "Obom"
          },
          "IndividualAttributes": {...},
          "IndividualProperties": {...}
     }]
  }
```

</p>
</details>

## Create multi-node simulations

<details><summary><span style="color: blue;">1. Generating demographics</span></summary>
<p>

To run simultaneous simulations in multiple nodes, create an input file "my_nodes.csv" with one row for each node.

Ex. "my_nodes.csv"

| nodeid | population | Village |
|--------|------------|---------|
| 1      | 1400       |"Obom"|
| 2      | 2255       |"Kofi Kwei"|
| 3      | 1800       |"Village 3"|

Then, run 

```{python,eval=F}
generate_demographics(df="/my_nodes.csv")
```

</p>
</details>

<details><summary><span style="color: blue;">2. Setting Node-Specific Inputs</span></summary>
<p>

Sometimes we want to vary properties between nodes based on prior knowledge. Imagine we know the proportion of "high-risk" individuals in each node and want to use this designation to target them for an intervention.

First, we would add a column to our input file representing the high-risk proportion in each node.

| nodeid | population | Village | high_risk |
|--------|------------|---------|-----------|
| 1 | 1400 | "Obom" | 0.05|
| 2 | 2255 | "Kofi Kwei" | 0.10|
| 3 | 1800 | "Village 3" | 0.50|

Then, when we can assign the "high_risk" property to individuals in each node with the probability listed in the table, by adding the following code to the end of the generate_demographics() function definition, before writing the .json file.

```{python, eval=F}
...
for n in list(range(current['Metadata']['NodeCount'])):
   current['Nodes'][n]['IndividualProperties'] = [{"Property":"high_risk",
   "Values": ['yes','no'],
   "Initial_Distribution": [high_risk, (1-high_risk)]}]
   

with open(demo_fname, 'w') as fout :
  json.dump(current, fout, sort_keys=True,indent=4, separators=(',', ': '))
```

We can see this reflected in the demographics file:

```{python, eval=F}
{
     "Metadata": {
          "DateCreated": "dateTime",
          "Tool": "scriptUsedToGenerate",
          "Author": "author",
          "IdReference": "Gridded world grump2.5arcmin",
          "NodeCount": "1"
     },
     "NodeProperties": [
          {...}
     ],
     "Defaults": {
         ...
     },
     "Nodes": [{
          "NodeID": 1,
          "NodeAttributes": {
            "BirthRate": 0.1190,
            "InitialPopulation": 1400,
            "Village": "Obom"
          },
          "IndividualAttributes": {...},
          "IndividualProperties": [
                {
                    "Initial_Distribution": [
                        0.05,
                        0.95
                    ],
                    "Property": "high_risk",
                    "Values": [
                        "yes",
                        "no"
                    ]
                }]},
                
     {
          "NodeID": 2,
          "NodeAttributes": {
            "BirthRate": 0.1690,
            "InitialPopulation": 2255,
            "Village": "Kofi Kwei"
          },
          "IndividualAttributes": {...},
          "IndividualProperties": [
                {
                    "Initial_Distribution": [
                        0.10,
                        0.90
                    ],
                    "Property": "high_risk",
                    "Values": [
                        "yes",
                        "no"
                    ]
                }]},
     {
          "NodeID": 3,
          "NodeAttributes": {
            "BirthRate": 0.2190,
            "InitialPopulation": 1800,
            "Village": "Village 3"
          },
          "IndividualAttributes": {...},
          "IndividualProperties": [
                {
                    "Initial_Distribution": [
                        0.50,
                        0.50
                    ],
                    "Property": "high_risk",
                    "Values": [
                        "yes",
                        "no"
                    ]
                }]}
  }
```

</p>
</details>

## Set up migration between nodes

Multi-node simulations allow for the possibility that humans or vectors will move between nodes.

**"Baseline" Migration**

<details><summary><span style="color: blue;">Human Migration (Local)</span></summary>
<p>

**Local** migration represents the movement of people in/out of nodes on foot. To specify migration rates, create a file "local_migration.csv" with columns specifying the origin node, destination node, and migration rate (1/trip duration). In the example below, people from Node 1 visit node 2 for 5 days (or vice versa), and people from Node 3 visit node 2 for 3 days (or vice versa). There is no local human movement between between Node 1 and Node 3.

|      |      |    |
|------|------|----|
|Node 1|Node 2| 0.2|
|Node 2|Node 1| 0.2|
|Node 2|Node 3| 0.33|
|Node 3|Node 2| 0.33|

Then, we have to convert the .csv to a .bin file EMOD can understand.

```{python,eval=F}

demo_fname = "inputs_path/my_demographics_file.json"
with open(demo_fname) as fin:
    demo = json.loads(fin.read())
id_reference = demo['Metadata']['IdReference']

convert_txt_to_bin('local_migration.csv',
                   'local_migration.bin',
                    id_reference=id_reference)
```

To connect that migration file a simulation, we need to change some configuration parameters. 

```{python, eval=F}
cb.update_params({
        # Migration
        'Migration_Model': 'FIXED_RATE_MIGRATION',   
        'Migration_Pattern': 'SINGLE_ROUND_TRIPS',

        'Enable_Local_Migration': 1,
        'Local_Migration_Roundtrip_Duration': 5,
        'Local_Migration_Roundtrip_Probability': 1,
        'x_Local_Migration': 0.02,  # Scale factor used to fix the average # of trips per person, per year.
        'Local_Migration_Filename': 'local_migration.bin'
    })
```

</p>
</details>

<details><summary><span style="color: blue;">Human Migration (Regional)</span></summary>
<p>

**Regional** migration represents the movement of people in/out of nodes by road or rail networks. However, this is not explicitly modeled, and you do not need to include these routes in your model to specify regional migration separately from local. The process is the same as for local migration, with different configuration parameter names. 

1. Create CSV
2. Convert to BIN
3. Update Configuration Parameters

```{python, eval=F}
cb.update_params({
        # Migration
        'Migration_Model': 'FIXED_RATE_MIGRATION',   
        'Migration_Pattern': 'SINGLE_ROUND_TRIPS',

        'Enable_Regional_Migration': 1,
        'Regional_Migration_Roundtrip_Duration': 30,
        'Regional_Migration_Roundtrip_Probability': 1,
        'x_Regional_Migration': 0.1,  # Scale factor used to fix the average # of trips per person, per year.
        'Regional_Migration_Filename': 'regional_migration.bin'
    })
```

</p>
</details>

<details><summary><span style="color: blue;">Vector Migration (Local)</span></summary>
<p>

The setup for vector movement between nodes is very similar to that for humans, but with different parameters. The table below is an example of a .csv file that can be used to generate a "vector_migration_local.bin" specifying equivalent vector migration between 2 adjacent nodes.

|      |      |      |
|------|------|------|
|Node 1|Node 2| 1.0  |
|Node 2|Node 1| 1.0  |

With the following updates to configuration parameters:

```{python, eval=F}
cb.update_params({
        'Enable_Vector_Migration': 1,
        'Enable_Vector_Migration_Local': 1,        
        'x_Vector_Migration_Local': 0.01,  # scale factor to fix average # of trips per vector, per day
        'Vector_Migration_Filename_Local': 'Vector_Local_Migration.bin',
        #"Vector_Migration_Base_Rate": 0.15,   (possibly redundant parameter, Tobias is looking into this 4/19/22)
        
        ### Modifying Equation parameters
        #   These must be specified, even if not used. 
        #   The default (no modification) parameters are below
        'Vector_Migration_Modifier_Equation': 'LINEAR',
        'Vector_Migration_Food_Modifier': 0, 
        'Vector_Migration_Habitat_Modifier': 0,
        'Vector_Migration_Stay_Put_Modifier': 0
    })
```

</p>
</details>

<p>
</p>

**Forced Migration**

You may want to incorporate migration that is different from the normal migration patterns described above.

<details><summary><span style="color: blue;">Forcing a Single Migration Event</span></summary>
<p>

Make sure the configuration parameters are set to allow migration:

```{python, eval=F}
cb.update_params({
        # Migration
        'Migration_Model': 'FIXED_RATE_MIGRATION',   
        'Migration_Pattern': 'SINGLE_ROUND_TRIPS'
  })
```

To add the migration events to the simulated campaign use add_migration_event(). 

```{python,eval=F}
from dtk.interventions.migrate_to import add_migration_event
# When is migration "initialized"?
start = 100
# Origin
node_from = 2
# Destination
node_to = 1
# How long after the "start" date should people wait to begin the trip?
duration_before_leaving = {"Duration_Before_Leaving_Distribution": "UNIFORM_DISTRIBUTION",
                           "Duration_Before_Leaving_Min": 1,
                           "Duration_Before_Leaving_Max": 7}
                           # Trips are staggered evenly over 7 days.
# How long should the trip last?
at_node = 30
duration_at_node = {"Duration_At_Node_Distribution": "CONSTANT_DISTRIBUTION",
                    "Duration_At_Node_Constant": at_node}
                    # Each trip lasts exactly 30 days.


add_migration_event(cb,
                    start_day=100,
                    nodesfrom=[2],
                    nodeto=node_to,
                    coverage=1.0,
                    duration_at_node= # time to spend at destination node,
                    duration_before_leaving=duration_before_leaving # time to remain home before trip,
                    ## [optional] targeting to subset of node population
                    ind_property_restrictions=[{"Property": property_value}], 
                    repetitions=1 # For a single event
                    )
```

More detail on specifying distributions for waiting/away times can be found in the [EMOD documentation - here](https://docs.idmod.org/projects/emod-malaria/en/latest/parameter-campaign-individual-migrateindividuals.html).

</p>
</details>

<details><summary><span style="color: blue;">Simulating Periodic Migration</span></summary>
<p>

For routine or seasonal migration events that repeat during a simulation, specify the number of repetitions and time-interval within add_migration_event()

```{python, eval=F}
add_migration_event(cb,
                    ...
                    repititions=4,
                    tsteps_btwn=365 # annual event
                    )
```

</p>
</details>

<details><summary><span style="color: blue;">Simulating Permanent Moves</span></summary>
<p>

EMOD also has a few other parameters built-in to the migrate_individuals campaign class:

- *DontAllowDuplicates* (default is False)
    - TRUE = While waiting to leave or during a trip, another migration event can't be initialized for a given individual. 
- *IsMoving* (default is False)
    - TRUE = a migration event changes individuals "home node" that they are considered a resident of (for other node-based interventions) **nodefrom** --> **nodeto**, even if they are on a short round-trip.

<span style="color: red;">**Note:**</span> the *IsMoving* parameter doesn't have anything to do with trip duration or a permanent relocation. These migration events are all round-trips. If you want to simulate a permanent move:

- set duration_at_node in add_migration_event() to a length of time that extends past the end of your simulation.
- Make sure *DontAllowDuplicates* in MigrateIndividuals() is FALSE if you want them to be eligible for future migration events after they change residence. 
- Set *IsMoving* in MigrateIndividuals() to True.

</p>
</details>

## Set the number of stochastic realizations (replicates) to run

The **Run_Number** config parameter sets the simulation's random seed. 
To run multiple stochastic realizations of the same simulation, vary **Run_Number** in the builder.
In this example, the builder creates 10 identical simulations except for the value of **Run_Number**, which ranges from 0-9.

```{python, eval=F}
from simtools.ModBuilder import ModBuilder, ModFn

expt_name = 'multi_seed_experiment'
numseeds = 10 

cb = DTKConfigBuilder.from_defaults('MALARIA_SIM)
builder = ModBuilder.from_list([[ModFn(DTKConfigBuilder.set_param, 'Run_Number', x)
                                 ]
                                for x in range(numseeds)
                                ])

run_sim_args = {
    'exp_name': expt_name,
    'config_builder': cb,
    'exp_builder' : builder
}
```

## Update config parameters

You may need to update a variety of configuration parameters for your simulations. These parameters can be explored more in depth in the [EMOD config documentation](https://docs.idmod.org/projects/emod-malaria/en/latest/parameter-configuration.html). Broadly, configuration parameters can be used to set up certain things in these categories: drugs and treatments, enable/disable features, general disease, geography and the environment, immunity, incubation, infectivity and transmission, input files, larval habitat, migration, mortality and survival, output settings, parasite dynamics, population dynamics, sampling, scalars and multipliers, simulation setup, symptoms and diagnosis, vector control, and vector life cycle. Generally, we create a setup_simulation() function that contains the configuration update function for the config_builder (cb). For parameters that won't often change you can hard code them directly into this function, while it may be beneficial to call others as a variable, such as sim_years, that can be set when the function itself is called later. This can be done inline in the code or within the model builder. 

A number of key parameters are featured in the code block below. Of particular note are how to change the **demographics** (Demographics_Filenames) and **simulation duration** (Simulation_Duration). Simulation duration is set in days, and in this example is set to last 7 years (7 yrs * 365 days/yr) rather than the setup_simulation() default of 2 years.

```{python,eval=F}
from dtk.utils.core.DTKConfigBuilder import DTKConfigBuilder

def setup_simulation(cb, sim_years=2):
    cb.update_params({'Demographics_Filenames': ['my_demographics.json'],
                      'Vector_Species_Names': [],
                      'Enable_Vital_Dynamics': 1,
                      'Enable_Birth': 1,
                      'Disable_IP_Whitelist': 1,
                      'Simulation_Duration': sim_years*365,
                      'Maternal_Antibodies_Type': 'CONSTANT_INITIAL_IMMUNITY',
                      'Incubation_Period_Distribution': 'CONSTANT_DISTRIBUTION'd,
                      'Birth_Rate_Dependence': 'FIXED_BIRTH_RATE',
                      'Climate_Model': 'CLIMATE_CONSTANT',
                      "Parasite_Smear_Sensitivity": 0.02,
                      'logLevel_JsonConfigurable': 'ERROR',
                      })
                      
cb = DTKConfigBuilder.from_defaults('MALARIA_SIM')
setup_simulation(cb,7)
```

### Enable births and deaths

Vital dynamics can be specified in the same way as general config parameters. They can be included within the same setup_simulation() function but are separated here for ease of access. In order to enable either births or deaths, **Enable_Vital_Dynamics** must be set to 1. Births and deaths can then be modified as needed ("enable" parameters set to 0 = false, 1 = true). Birth rates can be specified by **Birth_Rate_Dependence** to be dependent on a number of factors:  
- "NONE"
- "FIXED_BIRTH_RATE"
- "POPULATION_DEP_RATE"
- "DEMOGRAPHIC_DEP_RATE"
- "INDIVIDUAL_PREGNANCIES"
- "INDIVIDUAL_PREGNANCIES_BY_AGE_AND_YEAR"

Likewise, **Death_Rate_Dependence** determines individuals likelihood of dying from natural, non-disease causes when **Enable_Natural_Mortality**=1, and can be set to 
- "NOT_INITIALIZED" 
- "NONDISEASE_MORTALITY_BY_AGE_AND_GENDER"
- "NONDISEASE_MORTALITY_BY_YEAR_AND_AGE_FOR_EACH_GENDER"

Detailed descriptions of dependencies can be found [here](https://docs.idmod.org/projects/emod-malaria/en/latest/parameter-configuration-population.html).

```{python,eval=F}
def setup_simulation(cb, sim_years=2):
    cb.update_params({'Enable_Vital_Dynamics': 1,
                      'Enable_Birth': 1,
                      'Birth_Rate_Dependence' : 'FIXED_BIRTH_RATE'
                      'Enable_Disease_Mortality': 1,
                      'Enable_Natural_Mortality': 1,
                      'Death_Rate_Dependence':'NOT_INITIALIZED',
                      'Base_Mortality': 0.002
                      })
```

### Configure log-levels

Log levels dictate which logging messages will be included in the standard output for simulations. It can be set for all files in the Eradication executable using **logLevel_default** or for specific files where more information is desired with **logLevel_<file_name>**. There are five logging levels:

    1. ERROR: only errors logged
    2. WARNING: warning and errors logged
    3. INFO: default; informational messages, warnings, and errors logged
    4. DEBUG: debug information, informational messages, warnings, and errors logged. May require a special version of the executable (--TestSugar enabled)
    5. VALID: validation information, debug information, informational messages, warnings, and errors logged. Requires special build.

Lower levels (DEBUG and VALID) should be used sparingly but can be useful to understand if certain things, such as immunity variation, are working as expected.

```{python, eval=F}
def setup_simulation(cb, sim_years=2):
    cb.update_params({'logLevel_default' : 'WARNING',
                      'logLevel_<file_name>' : 'ERROR',
                      'logLevel_SusceptibilityMalaria': 'DEBUG' #file-specific example
    })
```

## Create the model builder

The following model builder implements some of the changes discussed above as well as references other specific functions from the NU team's SMC work.

```{python,eval=F}
from simtools.ModBuilder import ModBuilder, ModFn

builder = ModBuilder.from_list([[ModFn(smc_intervention, day=start_days, cycles=smc_cycles, coverage_level=smc_coverage),
                                 ModFn(set_EIR, EIRscale_factor=eir_scale_factor),
                                 ModFn(scale_cmax, cmax_scale_factor=cmax_scale_factor),
                                 ModFn(scale_krate, krate_scale_factor_AQ=krate_scale_factor_AQ,
                                 krate_sp=kmaxSP,num_groups = 100),
                                 ModFn(scale_c50, c50_AQ=1, c50_SP=c50SP, num_groups=100),
                                 ModFn(DTKConfigBuilder.set_param, 'Run_Number', x),
                                 ModFn(DTKConfigBuilder.set_param, 'Sample_Number', r),
                                 ModFn(sim_expl,pyr=pyr)
                                 ]
                                #for r, row in top_param_df[:num_params_to_run].iterrows()
                                for r in [1] 
                                for kmaxSP in [1.579]
                                for c50SP in [10.826]
                                for eir_scale_factor in [2]
                                for cmax_scale_factor in [1]
                                for smc_cycles in [1]
                                for krate_scale_factor_AQ in [1]
                                for smc_coverage in [0.9]
                                for start_days in [213]
                                for x in range(numseeds)
                                #for pyro in np.linspace(0.1,20000,10)
                                for pyr in [15000]
                                ])
```

## Set Forced EIR 

For simulations that don't use vector data to establish transmission, a forced EIR can be used as a proxy. These data are typically recreated from previous literature sources that provide monthly EIR levels, input here as a monthly_site_EIR list. This can then be converted to a daily EIR using the monthly_to_daily_EIR helper function and summed to calculate the annual EIR for the site. The add_InputEIR function is called and given the calculated daily EIR to apply to the simulations. It can be scaled using a scaling_factor in order to create the best fit to outcomes data.

```{python,eval=F}
from dtk.interventions.input_EIR import add_InputEIR
from helper_scripts.monthly_to_daily_EIR import monthly_to_daily_EIR

def set_EIR(cb, EIRscale_factor):
    monthly_site_EIR = [15.99, 5.41, 2.23, 10.33, 7.44, 11.77, 79.40, 85.80, 118.59, 82.97, 46.62, 33.49]
    
    daily_EIR = monthly_to_daily_EIR(monthly_site_EIR)
   
    add_InputEIR(cb, start_day=0, EIR_type='DAILY', dailyEIRs=daily_EIR, scaling_factor=EIRscale_factor)

    annual_eir = sum([x for x in daily_EIR])
  
    return {'EIR scale factor': EIRscale_factor}
```

## Add case management

Case management is controlled in EMOD by an [add_health_seeking()](https://github.com/InstituteforDiseaseModeling/dtk-tools-malaria/blob/master/malaria/interventions/health_seeking.py) function within dtk-tools-malaria. This function is a node level intervention that allows you to target individuals on the node for malaria treatment through health seeking behavior. In this example, treatment is triggered by a new clinical case and codes for differences in case management coverage between individuals of age 0-5 yrs and 5-100yrs as set by the two trigger dictionaries' respective 'agemin' and 'agemax'. 'Seek' dictates the proportion of people who will seek care with a new clinical case - it is often set to 1 such that 'coverage' is the true case management coverage level. 'Rate' represents the number of people a community health working can see, on average, each day. It is used to create an exponential distribution of the delay period until treatment. You can also specify which drugs are used for case management - the default is a combination of artemether and lumefantrine. 

Additional parameters can be added to restrict case management to certain nodes, node properties, or individual properties. See link to source code for more information. The case_management() function created here is typically called in the model builder.


```{python,eval=F}
from malaria.interventions.health_seeking import add_health_seeking

def case_management(cb, cm_cov_U5=0.5, cm_cov_adults=0.5):
    add_health_seeking(cb, start_day=0,
                       targets=[{'trigger': 'NewClinicalCase', 
                                 'coverage': cm_cov_U5, 
                                 'agemin': 0, 
                                 'agemax': 5,
                                 'seek': 1, 
                                 'rate': 0.3},
                                {'trigger': 'NewClinicalCase', 
                                 'coverage': cm_cov_adults, 
                                 'agemin': 5, 
                                 'agemax': 100,
                                 'seek': 1, 
                                 'rate': 0.3}],
                       drug=['Artemether', 'Lumefantrine'])
    

    return {'cm_cov_U5': cm_cov_U5,
            'cm_cov_adults': cm_cov_adults}

```

## Change drug adherence

Adherence to drugs can be modified using configure_adherent_drug(). This allows you to detail doses (and drugs given), intervals between doses, actual adherence values, and more.

```{python,eval=F}
from malaria.interventions.adherent_drug import configure_adherent_drug

def smc_adherent_configuration(cb, adherence):

    smc_adherent_config = configure_adherent_drug(cb,
                                                  doses=[["SulfadoxinePyrimethamine",'Amodiaquine'],
                                                         ['Amodiaquine'],
                                                         ['Amodiaquine']],
                                                  dose_interval=1,
                                                  non_adherence_options=['Stop'],
                                                  non_adherence_distribution=[1],
                                                  adherence_config={
                                                        "class": "WaningEffectMapCount",
                                                        "Initial_Effect": 1,
                                                        "Durability_Map": {
                                                            "Times": [
                                                                1.0,
                                                                2.0,
                                                                3.0
                                                            ],
                                                            "Values": [
                                                                1,
                                                                adherence,
                                                                adherence
                                                            ]
                                                        }
                                                    }
    )
    return smc_adherent_config
    
adherent_drug_configs = smc_adherent_configuration(cb, adherence)
```

## Adding drug campaigns

Using add_drug_campaign() you can set different drug campaigns including MDA, MSAT, SMC, fMDA, MTAT, rfMSAT, and rfMDA. This function also includes the ability to set coverage levels, repetitions (such as SMC cycles) and the timesteps between them, diagnostics information for campaigns that include testing, target groups, and restrictions on who can receive drugs by node or individual properties. For more details on all possible specifications see [malaria_drug_campaigns.py](https://github.com/InstituteforDiseaseModeling/dtk-tools-malaria/blob/master/malaria/interventions/malaria_drug_campaigns.py) in dtk-tools-malaria. Node and individual properties are set in the demographics file and can be called upon here for things like low vs high access groups.

This example details a simple SMC intervention. Its coverage level, number of cycles, and start day are specified in the model builder as they may change more regularly based on the purpose of different analyses. Timesteps between repetitions (if more than one cycle given) is set to 30 days as SMC is given on a monthly basis during peak season. The target group is also specified here to limit the age group to 0.25-5 year old children. This example dictates that it only applies to children classified as having "low" SMC access per the demographics file and uses adherent drug configurations as previously shown.

```{python,eval=F}
from malaria.interventions.malaria_drug_campaigns import add_drug_campaign

def smc_intervention(cb, day, cycles, coverage_level):
    add_drug_campaign(cb, campaign_type='SMC',
                          coverage=coverage_level, start_days=[(sim_years - 1) * 365 + day],
                          ind_property_restrictions=[{'Property_name': "Value"}],
                          repetitions=cycles, tsteps_btwn_repetitions=30,
                          adherent_drug_configs=[adherent_drug_configs],
                          target_group={'agemin': 0.25, 'agemax': 5},
                          receiving_drugs_event_name='Received_SMC')
```

## Setting up the experiment manager

The experiment manager serves as a mechanism to actually run simulations using the model and config builders. The respective builders, "builder" and "cb", are set up earlier in this list.

```{python,eval=F}
from simtools.SetupParser import SetupParser
from simtools.ExperimentManager.ExperimentManagerFactory import ExperimentManagerFactory

Exp_name = 'my_experiment_name'

run_sim_args = {
    'exp_name': Exp_name,
    'config_builder': cb,
    'exp_builder' : builder
}

if __name__ == "__main__":
    SetupParser.init()
    exp_manager = ExperimentManagerFactory.init()
    exp_manager.run_simulations(**run_sim_args)
```

## Add summary reports

Add description here

```{python,eval=F}
from malaria.reports.MalariaReport import add_summary_report

add_summary_report(cb, start=report_start, interval = interval,
                       age_bins=[0.25,5,100], ipfilter='SMCAccess:High',
                       description='Monthly_HAG_from_%d' % report_start)
```

## Add diagnostic surveys

Add description here

```{python,eval=F}
from malaria.interventions.malaria_drug_campaigns import add_drug_campaign, add_diagnostic_survey
                              
def diagnostic_survey(cb, sim_day, thresh=10, dose=1):
    # day 0 positivity
    add_diagnostic_survey(cb, start_day=sim_day,
                          diagnostic_threshold=thresh,
                          trigger_condition_list=[f'Received_IPTi_{dose}'],
                          positive_diagnosis_configs=[{'class': 'BroadcastEvent',
                                                       'Broadcast_Event': 'Day_0_positive'}],
                          negative_diagnosis_configs=[{'class': 'BroadcastEvent',
                                                       'Broadcast_Event': 'Day_0_negative'}],
                          triggered_campaign_delay=0)
                              #additional arguments
                              #repetitions=2, #2, 73
                              #tsteps_btwn_repetitions=365, #365, 7
                              #target={'agemin': val[0], 'agemax': val[1]},
                              #diagnostic_type='PF_HRP2',
```

